<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three Phase Task</title>
    <link rel="stylesheet" href="static/css/style.css">
</head>
<body>
    <div id="main" class="container">
        <div id="welcome" class="phase">
            <h1>Welcome to the Task</h1>
            <p style="margin-bottom: 10px;">Please enter your participant ID:</p>
            <input type="text" id="participantIdInput" placeholder="e.g., P001" style="padding: 8px; font-size: 16px; width: 200px; margin-bottom: 15px;">
            <br>
            <button onclick="startWithID()" style="padding: 10px 20px; font-size: 16px;">Start Task</button>
        </div>

        <div id="explorephase" class="phase" style="display:none;">
            <h1>Task Phase</h1>
            <canvas id="gameCanvas" width="500" height="500"></canvas>
            <p>Use arrow keys to move the character.</p>
        </div>

        <!-- <div id="identificationphasetwo" class="phase" style="display:none;">
          <h1>Identification Phase Two</h1>
          <canvas id="two_idenCanvas" width="500" height="500"></canvas>
          <button id='next_mem' onclick="startMemorry()">Next Task</button>
        </div> -->

        <div id="memoryphase" class="phase" style="display: none;">
            <h1>Memory Phase</h1>
            <div id="memorySelectorPhase" style="position: relative; display: flex; justify-content: center; align-items: center; height: 500px; gap: 100px;">
                <!-- Selector highlight circle -->
                <div id="selectorBox" style="
                    position: absolute;
                    top: 50%;
                    transform: translateY(-50%);
                    width: 110px;
                    height: 110px;
                    border: 4px solid black;
                    border-radius: 50%;
                    transition: left 0.2s ease;
                    pointer-events: none;
                    z-index: 1;
                "></div>
        
                <!-- Left mushroom -->
                <div id="leftMushroomBox" style="position: relative; width: 120px; text-align: center;">
                    <img id="leftMushroomImg" src="" style="width: 100px;">
                </div>
        
                <!-- Middle empty space -->
                <div id="middleSpacer" style="width: 120px; height: 100px;"></div>
        
                <!-- Right mushroom -->
                <div id="rightMushroomBox" style="position: relative; width: 120px; text-align: center;">
                    <img id="rightMushroomImg" src="" style="width: 100px;">
                </div>
            </div>
        </div>

        <div id="thankyou" class="phase" style="display:none;">
            <h1>Thank You!</h1>
            <p>Thank you for completing the task.</p>
        </div>
    </div>
    <!-- CSV parser (robust) -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

    <!-- Adapter (GLOBAL). We wrap your module into window.* helpers inline for simplicity -->
    <script type="module">
    import { loadMushroomCatalog, preloadCatalogImages, makeLevelMushroomsFromCatalog } from "./static/js/mushroom_catalog_adapter.js";
    window.loadMushroomCatalog = loadMushroomCatalog;
    window.preloadCatalogImages = preloadCatalogImages;
    window.makeLevelMushroomsFromCatalog = makeLevelMushroomsFromCatalog;

    // Boot the catalog once; expose a promise others can await.
    window.CATALOG_READY = (async () => {
        // Where your generator wrote files originally:
        const stripPrefix = "/Users/jianleguo/Desktop/MUSHROOM/Dimensionality_Reward_Setup/images_balanced";
        // Where they are hosted in your app:
        const imageBaseUrl = "TexturePack/Mushroom_pack/images_balanced";

        window.MUSHROOM_IMAGE_BASE_URL = imageBaseUrl;
        // Use the stable CSV you exported (or symlink) into that folder:
        const csvUrl = "TexturePack/Mushroom_pack/images_balanced/mushroom_catalog_balanced_latest.csv";

        const catalog = await window.loadMushroomCatalog({ csvUrl, imageBaseUrl, stripPrefix });
        await window.preloadCatalogImages(catalog);
        window.MUSHROOM_CATALOG = catalog;
        console.log("Catalog ready:", catalog.length);
        return catalog;
    })();
    </script>

    <script>
    /**
     * Generate 5 non-overlapping mushroom sets (A–E) from the catalog, each targeting a different hypothesis:
     *  A: Perceptual-similarity cluster (same color; tight cap_roundness band; varied stems) — good for OOO.
     *  B: Value gradient (same color; wide spread of assigned_value) — tests value learning mapping.
     *  C: Color–value dissociation (mixed colors, values tightly matched) — decouple value from color.
     *  D: Feature-specific variation (fix cap_roundness band; vary stem_width across bins) — feature learning.
     *  E: Value extremes (global low/high tails) — robust for memory effects and generalization.
     *
     * Assumes catalog rows expose: imagefilename, assigned_value, color_name, cap_roundness, stem_width.
     * If zone columns are missing, we compute numeric ranges directly.
     */
    window.generateMushroomSets = async function generateMushroomSets() {
    if (window.CATALOG_READY && typeof window.CATALOG_READY.then === "function") {
        await window.CATALOG_READY;
    }
    const cat = (window.MUSHROOM_CATALOG || []).slice();

    // ---------- helpers ----------
    const baseURL = window.MUSHROOM_IMAGE_BASE_URL || "TexturePack/mushroom_pack/images_balanced";
    const num = (x, fallback = 0) => (x == null || x === "" ? fallback : +x);
    const uniqBy = (arr, keyFn) => {
        const seen = new Set();
        const out = [];
        for (const x of arr) {
        const k = keyFn(x);
        if (!seen.has(k)) { seen.add(k); out.push(x); }
        }
        return out;
    };
    const shuffle = (arr) => arr.map(v => [Math.random(), v]).sort((a,b)=>a[0]-b[0]).map(v=>v[1]);
    const pickN = (arr, n, usedKeys, keyFn) => {
        const out = [];
        for (const row of arr) {
        const k = keyFn(row);
        if (usedKeys.has(k)) continue;
        out.push(row); usedKeys.add(k);
        if (out.length >= n) break;
        }
        return out;
    };
    const keyByFile = (m) => m.imagefilename || m.name || JSON.stringify(m);

    // annotate & sanitize core fields
    for (const m of cat) {
        m.assigned_value  = num(m.assigned_value);
        m.cap_roundness   = num(m.cap_roundness);
        m.stem_width      = num(m.stem_width);
        m.color_name      = m.color_name || m.color || "unknown";
        m.imagefilename   = m.imagefilename || m.image || m.file || "";
        m.name = m.name || `${m.color_name}_${m.imagefilename || Math.random().toString(36).slice(2,7)}`;
        m.image_url = `${baseURL}/${m.imagefilename}`;
    }

    // Remove obvious duplicates by filename
    const catalog = uniqBy(cat.filter(m => m.imagefilename), keyByFile);
    if (catalog.length < 30) {
        console.warn("Catalog is small; sets may overlap conceptually.");
    }

    // Value quantiles
    const vals = catalog.map(m => m.assigned_value).sort((a,b)=>a-b);
    const qAt = (q) => vals[Math.max(0, Math.min(vals.length - 1, Math.floor(q * (vals.length - 1))))];
    const q10 = qAt(0.10), q25 = qAt(0.25), q75 = qAt(0.75), q90 = qAt(0.90);

    // Choose a reference color that has enough items
    const colorCounts = new Map();
    for (const m of catalog) colorCounts.set(m.color_name, 1 + (colorCounts.get(m.color_name) || 0));
    let refColor = "red";
    let maxN = -1;
    for (const [c,n] of colorCounts.entries()) if (n > maxN) { maxN = n; refColor = c; }

    // Buckets
    const byColor = (c) => catalog.filter(m => m.color_name === c);
    const sameColor = byColor(refColor);
    const others    = catalog.filter(m => m.color_name !== refColor);

    // Utility: select a tight band around the median of a field
    const tightBand = (arr, field, width) => {
        const arrS = arr.slice().sort((a,b)=>a[field]-b[field]);
        const med  = arrS[Math.floor(arrS.length/2)]?.[field] ?? 0;
        return arr.filter(m => Math.abs(m[field] - med) <= width);
    };

    // Want roughly these sizes; adjust if you prefer
    const SIZE_A = 12;  // enough to draw multiple OOO triplets
    const SIZE_B = 16;  // value gradient
    const SIZE_C = 12;  // value-matched, mixed color
    const SIZE_D = 12;  // feature-specific variation
    const SIZE_E = 16;  // extremes (low+high)

    const used = new Set(); // track filenames to avoid cross-set overlap

    // --- A: Perceptual-similarity cluster (same color; tight cap band; varied stems) ---
    let A_pool = tightBand(sameColor, "cap_roundness", /*width*/0.05);
    if (A_pool.length < SIZE_A) A_pool = sameColor; // fallback
    A_pool = shuffle(A_pool);
    const A = pickN(A_pool, SIZE_A, used, keyByFile);

    // --- B: Value gradient within same color (spread across quantiles) ---
    const B_low   = sameColor.filter(m => m.assigned_value <= q25);
    const B_high  = sameColor.filter(m => m.assigned_value >= q75);
    const B_mid   = sameColor.filter(m => m.assigned_value > q25 && m.assigned_value < q75);
    let B_pool = shuffle([ ...(B_low||[]), ...(B_mid||[]), ...(B_high||[]) ]);
    const B = pickN(B_pool, SIZE_B, used, keyByFile);

    // --- C: Color–value dissociation (mixed colors; values tightly matched around global median) ---
    const medianV = qAt(0.5);
    let C_pool = catalog.filter(m => Math.abs(m.assigned_value - medianV) <= 1.0);
    // prefer mixed colors
    C_pool = shuffle(C_pool);
    const C = pickN(C_pool, SIZE_C, used, keyByFile);

    // --- D: Feature-specific variation (cap band tight; vary stem_width) ---
    let D_pool = tightBand(catalog, "cap_roundness", /*width*/0.05)
                    .sort((a,b) => a.stem_width - b.stem_width);
    if (D_pool.length < SIZE_D) D_pool = catalog.slice();
    D_pool = shuffle(D_pool);
    const D = pickN(D_pool, SIZE_D, used, keyByFile);

    // --- E: Value extremes (global low & high tails), good for memory/generalization ---
    const E_tail = catalog.filter(m => m.assigned_value <= q10 || m.assigned_value >= q90);
    let E_pool = shuffle(E_tail.length ? E_tail : catalog);
    const E = pickN(E_pool, SIZE_E, used, keyByFile);

    // Ensure each element has a usable name & direct image_url (already added)
    const decorate = (arr) => arr.map((m,i) => ({
        ...m,
        name: m.name || `${m.color_name}_${m.imagefilename || i}`,
        image_url: m.image_url || `${baseURL}/${m.imagefilename}`
    }));

    return {
        A: decorate(A),
        B: decorate(B),
        C: decorate(C),
        D: decorate(D),
        E: decorate(E)
    };
    };
    </script>

    <script src="static/js/data_save.js"></script>
    <script src="static/js/mushroom_filename.js"></script>
    <script src="static/js/mushroom.js"></script>
    <script src="static/js/idenphase.js"></script>
    <script src="static/js/memory_phase.js"></script>
    <script src="static/js/game_env.js"></script>
    <script src="static/js/game_function.js"></script>
    <script src="static/js/task.js"></script>
    <script src="static/js/Odd_One_Out_Phase.js"></script>
</body>
</html>